22/05 :

Début du projet, arborescence faite et layout fait;
Composants : Hero fait
Ajout de style dans le globals.css 

Il faut rajouter les <input> dans les lignes pour chaque case pour
que le joueur puisse écrire + qu'on puisse récupérer l'input

Modifier les noms des classes/ID pour les lignes
(AttemptRow => wordRow);

Pour passer à la case d'après après l'input :

<input onChange={pushLetterFunction}>
pushLater(event){

    event.target.nextElementSibling.focus()
}

Faire en sorte que lorsqu'on a vérifié pour la dernière fois le mot
(Victoire ou défaite), supprimer de la table Game le mot à deviner
associé au playerID.

26/05 :

Ajout dyanmique des balises input dans le composant AttemptRow
Ajout dynamique des balises <AttemptRow /> dans le composant GameGrid

[...Array(6)] = Création d'un tableau de taille 6 initialisé (6 x undefined);
.map pour faire un tableau pour pouvoir itérer dessus

Faire un bouton ou quelque chose pour les règles, lorsqu'on appuie dessus un pop up apparait ou un truc du genre pour ensuite afficher
les règles, comme par exemple appuyer sur entrée lorsque le mot tapé est complet, ou alors faire en sorte de check la longueur
de la chaine, et si la chaine != wordLength alors on ne fait pas de requête post vers la route api/guess pour ne pas vérifier

Trouver un moyen de "verrouiller" toutes les lignes sauf celle jouable

Lorsque le premier composant interragit avec la BDD (pseudo),
c'est lui qui va créer la ligne dans ma table Player pour ce joueur.
Je dois ensuite récupérer le insertID, et l'envoyer en réponse au 
client pour le stocker dans le localstorage. Lorsque je dois modifier 
un champ de sa table (les points par exemple), j'envoie le playerID stocké en localstorage,
et je fais un update sur ce champ la en précisant (UPDATE Player SET points = +50pts WHERE playerID = variable.insertID)
un truc comme ça 

Pour éviter d'envoyer d'autres lignes non concernées par écriture,
changer maxlength input à 0 si ce n'est pas la ligne actuellement
jouable

SET LE attemptsNumber pour faire en sorte que le joueur ne joue plus
lorsqu'il a réalisé 6 essais ou s'il a trouvé le mot
Si isGameFinished == true, afficher les balises p et tout ?

Faire en sorte de modifier le placeholder pour les lettres à la bonne place


                                         VÉRIFIER ET SUPPRIMER LES CLASSES (hero.css):
-------------------------------------------------------------------------------------------------------------------------------------
<form className="chose-username-form" onSubmit={chooseUsername}>

    <input placeholder="Entrez un pseudo" name="username-input" type="text" maxLength={20} className="chose-username-input"/>
    <input type="submit" hidden/>

</form>
-------------------------------------------------------------------------------------------------------------------------------------

Faire un bouton rejouer lorsque la partie est terminée ? 
Reset les valeurs attemptsNumber (0) & isGameFinished (false) ?

Bien faire les variables d'environnement :

Bien remplir le fichier .env, puis lorsque testé et sûr qu'il est correctement
rempli, le renommer en .env.local, pour qu'il passe le gitignore, et qu'il soit
utilisable en le renommant .env (à mettre dans le readme), et regarder
plus d'infos sur le .env.local

RÉGLER LE PROBLÈME OÙ LORSQUE JE REFRESH LA PAGE GAME, ÇA FAIT UN INSERT
ET CRÉE UNE NOUVELLE LIGNE DANS LA TABLE GAME LIÉ A UN MÊME JOUEUR
Faire un select, vérifier si il y a au moins un champ dans la colonne wordToGuess,
si oui faire le insert, sinon le laisser

Une route POST doit avoir comme paramètre seulement req, un GET un res

Faire en sorte de faire une boucle sur l'objet reçu de "correction"
pour vérifier les status (if object[i].status == "correct") goodAnswerCount += 1;
if(goodAnswerCount == wordLength){

    setIsGameFinished(true);
}

Faire en sorte de :

    - Lorsque le mot est trouvé, refresh la page ou simplement affiché
    la fin de partie en mettant à jour isGameFinished
    - Mettre à jour le mot car lorsqu'il est trouvé on delete
    - Changer placeholder/couleur du mot en fonction des résultats